# ModuleHub <br>
Система ModuleHub решает проблему отсутствия централизованного, удобного и модерируемого ресурса для поиска, оценки и обсуждения Magisk-модулей. <br>
* Для всех пользователей (включая гостей):
  * Просмотр списка модулей с фильтрацией и сортировкой (по категориям, рейтингу, дате добавления, популярности).
  * Поиск модулей по названию, описанию, тегам, автору.
  * Просмотр детальной информации о модуле: описание, автор, версии, скриншоты (если применимо), отзывы, отчеты о совместимости.
* Для зарегистрированных Пользователей (EndUser):
  * Все функции гостя.
  * Оставление отзывов и выставление рейтинга модулям.
  * Отправка отчетов о совместимости модуля с их устройством и версией Android.
  * Подписка на уведомления о новых версиях любимых модулей (опционально).
* Для зарегистрированных Разработчиков (Developer):
    * Все функции Пользователя.
    * Загрузка своих Magisk-модулей (метаданные и ссылка на скачивание).
    * Управление своими модулями: редактирование описания, добавление новых версий, просмотр статистики (скачивания, отзывы).
    * Просмотр отзывов и отчетов о совместимости для своих модулей.
* Для Модераторов (Moderator):
    * Все функции Пользователя.
    * Верификация новых модулей перед их публичным размещением.
    * Модерация отзывов и отчетов о совместимости.
    * Управление категориями и тегами.
 
Для проектирования системы были выбраны следующие UML-диаграммы:
* **Диаграмма классов (Class Diagram):** <br>
        Почему: Это диаграмма, которая показывает статическую структуру системы: основные классы, их атрибуты (данные), методы (поведение) и связи между ними (ассоциации, наследование, агрегация).

  ![Untitled](https://github.com/user-attachments/assets/a33ea1b5-8be2-4f39-9755-d3e95e68ed40)



# Структура Базы Данных

Для хранения данных приложения "ModuleHub" используется реляционная база данных: PostgreSQL. Схема базы данных спроектирована для эффективного хранения информации о пользователях, модулях, их версиях, отзывах, категориях, тегах и отчетах о совместимости.

Ключевые сущности и их таблицы:
* **Roles**
  * Описание: Хранит предопределенные роли пользователей в системе.
  * Ключевые поля: RoleID (PK), RoleName.
  * Пример ролей: "EndUser", "Developer", "Moderator".
* **Users**
  * Описание: Основная таблица для хранения информации о всех зарегистрированных пользователях.
  * Ключевые поля: UserID (PK), Username, Email, PasswordHash, RegistrationDate, RoleID (FK к Roles).
* **DeveloperProfiles**
  * Описание: Дополнительная информация для пользователей с ролью "Разработчик". Реализует связь "один-к-одному" с таблицей Users.
  * Ключевые поля: UserID (PK, FK к Users), Bio, WebsiteUrl.
* **ModuleCategories**
  * Описание: Определяет категории, к которым могут принадлежать Magisk-модули (например, "Твики UI", "Производительность", "Звук").
  * Ключевые поля: CategoryID (PK), CategoryName, Description.
* **Modules**
  * Описание: Центральная таблица, хранящая информацию о самих Magisk-модулях.
  * Ключевые поля: ModuleID (PK), Name, Description, AuthorUserID (FK к Users), CategoryID (FK к ModuleCategories), IsVerified, CreationDate, LastUpdateDate.
* **ModuleVersions**
  * Описание: Хранит информацию о различных версиях каждого модуля, включая ссылку на скачивание и список изменений.
  * Ключевые поля: VersionID (PK), ModuleID (FK к Modules), VersionString, Changelog, DownloadLink, MinMagiskVersion, FileSizeMB, UploadDate.
* **Reviews**
  * Описание: Содержит отзывы и оценки, оставленные пользователями для конкретных модулей.
  * Ключевые поля: ReviewID (PK), ModuleID (FK к Modules), UserID (FK к Users), Rating, CommentText, ReviewDate, IsEdited.
* **Compatibility**
  * Описание: Позволяет пользователям сообщать о совместимости определенной версии модуля с их устройством и версией Android.
  * Ключевые поля: ReportID (PK), ModuleVersionID (FK к ModuleVersions), UserID (FK к Users), DeviceModel, AndroidVersion, WorksStatus, UserNotes, ReportDate.
* **Tags**
  * Описание: Хранит список тегов, которые можно присваивать модулям для более гибкой классификации и поиска (например, "Xposed", "SafetyNet Bypass").
  * Ключевые поля: TagID (PK), TagName.
* **ModuleTags**
  * Описание: Связующая таблица для реализации связи "многие-ко-многим" между модулями и тегами. Каждый модуль может иметь несколько тегов, и каждый тег может быть применен к нескольким модулям.
  * Ключевые поля: ModuleID (PK, FK к Modules), TagID (PK, FK к Tags).


# Основные команды консольного интерфейса MagiskHub

Консольное приложение предоставляет интерфейс для взаимодействия с системой MagiskHub. Меню и доступные команды зависят от того, залогинен ли пользователь и какая у него роль.

### Команды для всех (Гость)

*   **1. Просмотр всех модулей:**
    *   Назначение: Отображает список всех модулей в системе с основной информацией (ID, Название, Автор, Категория, Статус верификации).
*   **2. Поиск модуля по названию:**
    *   Назначение: Позволяет найти модули, название которых содержит указанную пользователем подстроку.
*   **3. Регистрация:**
    *   Назначение: Позволяет новому пользователю создать аккаунт в системе. По умолчанию пользователь регистрируется с ролью "EndUser".
    *   Требуемые данные: Имя пользователя, Email, Пароль.
*   **4. Вход:**
    *   Назначение: Позволяет существующему пользователю войти в свой аккаунт.
    *   Требуемые данные: Имя пользователя, Пароль.
*   **0. Выход:**
    *   Назначение: Завершает работу консольного приложения.

### Команды для аутентифицированных пользователей (EndUser, Developer, Moderator)

В дополнение к командам гостя (кроме регистрации и входа, которые заменяются на опцию "Выйти из аккаунта"):

*   **3. Оставить отзыв на модуль:**
    *   Назначение: Позволяет пользователю оставить текстовый отзыв и выставить оценку (1-5) для выбранного модуля.
    *   Требуемые данные: ID модуля, Оценка, Текст комментария.
*   **4. Сообщить о совместимости версии модуля:**
    *   Назначение: Позволяет пользователю сообщить, как конкретная версия модуля работает на его устройстве.
    *   Требуемые данные: ID версии модуля, Модель устройства, Версия Android, Статус работы (Works/WorksWithIssues/DoesNotWork), Заметки.
*   **9. Выйти из аккаунта:**
    *   Назначение: Позволяет текущему пользователю выйти из своего аккаунта, возвращая его в меню гостя.

### Команды для Разработчиков (Developer)

В дополнение ко всем командам аутентифицированного пользователя:

*   **D1. Загрузить новый модуль:**
    *   Назначение: Позволяет разработчику добавить новый модуль в систему. При загрузке модуля также создается его первая версия. Модуль ожидает верификации модератором.
    *   Требуемые данные: Название модуля, Описание, ID Категории, Строка первой версии, Ссылка на скачивание, Changelog.
*   **D2. Добавить новую версию к моему модулю:**
    *   Назначение: Позволяет разработчику добавить новую версию для одного из своих существующих модулей.
    *   Требуемые данные: ID модуля, Строка новой версии, Ссылка на скачивание, Changelog.
*   **D3. Просмотреть мои модули:**
    *   Назначение: Отображает список всех модулей, автором которых является текущий разработчик, включая их версии.

### Команды для Модераторов (Moderator)

В дополнение ко всем командам аутентифицированного пользователя:

*   **M1. Верифицировать модуль:**
    *   Назначение: Позволяет модератору просмотреть список не верифицированных модулей и одобрить (верифицировать) выбранный модуль, делая его видимым и доверенным для других пользователей.
*   **M2. Управление категориями:**
    *   Назначение: Добавление, редактирование, удаление категорий модулей.
*   **M3. Управление тегами:**
    *   Назначение: Добавление, редактирование, удаление тегов.

<br>

# Слой работы с базой данных (Data Access Layer - DAL)

### Структура и Паттерны

*   **Repository Pattern (Паттерн "Репозиторий"):**
    *   Для каждой основной бизнес-сущности (например, `User`, `Module`, `ModuleCategory`, `Tag`) создан свой репозиторий. Репозиторий действует как коллекция объектов в памяти, предоставляя методы для добавления, получения, изменения и удаления сущностей, абстрагируясь от конкретного способа хранения.
    *   **Интерфейсы репозиториев** (например, `IUserRepository`, `IModuleRepository`): Определяют контракт (набор методов), которому должны соответствовать конкретные реализации репозиториев. Использование интерфейсов способствует слабой связанности между слоем DAL и бизнес-логикой (или слоем представления), а также упрощает модульное тестирование.
    *   **Конкретные классы репозиториев** (например, `UserRepository`, `ModuleRepository`): Реализуют соответствующие интерфейсы. Внутри этих классов используется Entity Framework Core для выполнения операций с базой данных.

*   **`IDbContextFactory<MagiskHubContext>`:**
    *   Вместо прямого внедрения экземпляра `MagiskHubContext` (который представляет сессию с БД) в конструкторы репозиториев, используется фабрика `IDbContextFactory<MagiskHubContext>`.
    *   **Преимущество:** Фабрика позволяет создавать короткоживущие экземпляры `DbContext` внутри каждого метода репозитория (`using var context = _contextFactory.CreateDbContext();`). Это гарантирует, что каждый `DbContext` используется для ограниченного набора операций и правильно освобождается, что особенно важно в приложениях, где нет четкого "запроса" (как в веб-приложениях), в рамках которого `DbContext` мог бы жить. Такой подход помогает избежать проблем с отслеживанием слишком большого количества сущностей или с устаревшими данными в кэше контекста.

*   **Синхронное выполнение операций:**
    *   В данной версии приложения все операции взаимодействия с базой данных реализованы **синхронно**. Это означает, что методы репозиториев не возвращают `Task` или `Task<T>`, а выполняют операции блокирующим образом.
    *   Это упрощает структуру вызовов в консольном приложении, но следует учитывать, что при длительных операциях с БД это может приводить к "зависанию" интерфейса. Для более сложных или высоконагруженных систем предпочтительнее асинхронный подход.

### Основные компоненты

*   **Пространство имен:** `MagiskHub.DataAccess` (содержит все компоненты DAL).
*   **Интерфейсы репозиториев:**
    *   `IRoleRepository`
    *   `IUserRepository`
    *   `IModuleCategoryRepository`
    *   `ITagRepository`
    *   `IModuleRepository`
    *   `IModuleVersionRepository`
    *   `IReviewRepository`
    *   `ICompatibilityReportRepository`
*   **Классы репозиториев:**
    *   `RoleRepository`
    *   `UserRepository`
    *   `ModuleCategoryRepository`
    *   `TagRepository`
    *   `ModuleRepository`
    *   `ModuleVersionRepository`
    *   `ReviewRepository`
    *   `CompatibilityReportRepository`
*   **Пользовательское исключение:**
    *   `DataAccessException.cs`: Используется для обертывания специфических исключений Entity Framework Core (например, `DbUpdateException`) и предоставления более общего типа ошибки слоям выше. Это позволяет централизованно обрабатывать ошибки доступа к данным.

### Взаимодействие и Конфигурация

1.  **Внедрение зависимостей (Dependency Injection - DI):**
    *   В главном методе приложения (`Program.Main`) используется `Microsoft.Extensions.DependencyInjection` для настройки контейнера DI.
    *   Регистрируется `IDbContextFactory<MagiskHubContext>`:
        ```csharp
        services.AddDbContextFactory<MagiskHubContext>(options =>
            options.UseNpgsql(connectionString)); // Или другой провайдер БД
        ```
    *   Регистрируются интерфейсы репозиториев и их конкретные реализации:
        ```csharp
        services.AddScoped<IUserRepository, UserRepository>();
        // ... и так далее для всех репозиториев
        ```
        (Хотя для консольного приложения, где зависимости разрешаются один раз в `Main`, разница между `Scoped`, `Transient` и `Singleton` для репозиториев может быть не так заметна, `Scoped` является хорошей практикой, если бы приложение имело более сложный жизненный цикл).
2.  **Получение репозиториев:**
    *   Экземпляры репозиториев получаются из сервис-провайдера в `Program.Main` и сохраняются в статические поля для использования в методах консольного интерфейса.
3.  **Использование:**
    *   Методы консольного интерфейса (в `Program.cs`) вызывают методы соответствующих репозиториев для выполнения операций с данными. Например, для регистрации пользователя будет вызван `_userRepository.AddUser(newUser);`.

### Обработка ошибок

*   Каждый метод репозитория, выполняющий операции изменения данных (`SaveChanges()`) или потенциально проблемные запросы, обернут в блок `try-catch`.
*   При возникновении `DbUpdateException` (или других релевантных исключений EF Core), оно перехватывается и выбрасывается новое исключение `DataAccessException` с исходным исключением в качестве `InnerException`.
*   Слой представления (консольный интерфейс в `Program.cs`) имеет общий обработчик для `DataAccessException`, который выводит сообщение об ошибке пользователю.

### Примеры запросов (внутри репозиториев)

*   **Чтение:** Используются LINQ-запросы к `DbSet<T>` с методами, такими как `ToList()`, `FirstOrDefault()`, `Find()`, `Where().ToList()`. Для запросов только на чтение активно используется `.AsNoTracking()`, чтобы Entity Framework Core не отслеживал изменения для этих сущностей, что может улучшить производительность. Связанные данные подгружаются с помощью `.Include()` и `.ThenInclude()`.
*   **Создание:** Используется метод `Add()` на `DbSet<T>`, за которым следует `SaveChanges()` на экземпляре `DbContext`.
*   **Обновление:** Сущность либо получается из контекста (и тогда она уже отслеживается), либо, если она не отслеживается (например, пришла из другого слоя), используется метод `Update()` на `DbSet<T>`, за которым следует `SaveChanges()`.
*   **Удаление:** Сущность получается (обычно методом `Find()`), затем используется метод `Remove()` на `DbSet<T>`, и `SaveChanges()`.
